# **刷题部分：**基础知识

## js 实现 链表

单链表是表示一系列节点的数据结构，其中每个节点指向链表中的下一个节点。 相反，双向链表具有指向其前后元素的节点。

与数组不同，链表不提供对链表表中特定索引访问。 因此，如果需要链表表中的第三个元素，则必须遍历第一个和第二个节点才能到得到它。

- 节点

链表只是一系列节点，所以让我们从 Node 对象开始。

链表  一个节点有两条信息

- 指向链表中下一项的指针或引用(对于单链表)
- 节点的值

对于我们的节点，我们只需要创建一个函数，该函数接受一个值，并返回一个具有上面两个信息的对象:**指向下一个节点的指针和该节点的值**。

节点链表将包含五个方法：

- **push(value)**: 将值添加到链表的末尾
- **pop()** ：弹出链表中的最后一个值
- **get(index)**：返回给定索引中的项
- **delete(index)**：从给定索引中删除项
- **isEmpty()**: 返回一个布尔值，指示链表是否为空

**printList()**:不是链表的原生方法，它将打印出我们的链表，主要用于调试



## var/let/const的区别及使用场景

var 

- var定义的变量会预解析，

  简单的说就是如果变量没有定义就直接使用的话，JavaScript回去解析这个变量，代码不会报错，只会输出undefined

  ```
  console.log(a)
  var a = 1 // undefined
  ```

- var定义的变量可以反复去定义，当然后面的会覆盖前面的

  ```
  var a = 1
  var a = 2 
  console.log(a) //2
  ```

- var在循环中使用的时候，循环体外依然可以使用

  ```
  for(var i = 0 ;i<5;i++){
      console.log(i)
  }
  console.log(i)  //5
  ```

- 在循环绑定事件过程中，var定义的变量无法保存，循环会在瞬间执行完

  ```
    var arrLi = document.getElementsByTagName('li')
          for(var i=0;i<arrLi.length;i++){
              arrLi[i].onclick = function () {
                  console.log(arrLi[i])// undefined 
              }
          }
  ```

let 

- let定义的变量不会预解析，必须先声明再使用，否则会报错

  ```
  console.log(a)
  let a = 1 // ReferenceError: Cannot access 'a' before initialization
  ```

- let不能定义已经定义过的变量（无论之前是用var定义的还是let或者const定义的）

  ```
   var a = 1
          let a = 2 
          console.log(a) //Uncaught SyntaxError: Identifier 'a' has already been declared
  ```

- let是块级作用域，函数内部使用let定义后，对函数外部无影响，简单说就是在一个{}里面生效

  ```
   for(let i = 0 ;i<5;i++){
              console.log(i)
          }
          console.log(i)  //err
  ```

- 4，由于let是块级作用域，在循环绑定事件过程中let会在这个循环中生效，再次循环时let会重新定义生效

  ```
   var arrLi = document.getElementsByTagName('li')
          for(let i=0;i<arrLi.length;i++){
              arrLi[i].onclick = function () {
                  console.log(arrLi[i])
              }
          }
  ```

const

- const定义的变量不会预解析，必须先声明再使用，否则会报错

  ```
  console.log(a)
  const a = 1 // ReferenceError: Cannot access 'a' before initialization
  ```

- const定义的变量不允许修改

  ```
  const a = 1 
  console.log(a)
  a = 5 //TypeError: Assignment to constant variable.
  ```

  - 但是在数组里面，const的值是允许被修改的，这是因为const存储的是地址，值的内容可以变化

    ```
    const arr1 = [1,2,3,4,5]
    arr1[3] = 100 
    console.log(arr1) //[ 1, 2, 3, 100, 5 ]
    ```

    

所有 总结就是

一般变量不变的 用const

for循环中用  let

反复定义用 var 



## 排序函数的应用 sort

```
let nums = [-1,0,1,2,-4,-3,0,4]

let num2 = nums.sort()
console.log(nums) //[-1, -3, -4, 0, 0,  1,  2, 4]

let num1 = nums.sort(function (a,b) {
    return a-b
})   //正确的对nums的排序 
console.log(nums) //[-4, -3, -1, 0, 0,  1,  2, 4]
console.log(num2,num1) //[ -4, -3, -1, 0,0,  1,  2, 4] [ -4, -3, -1, 0,0,  1,  2, 4]

```

使用排序算法的时候  调用改方法会改变原数组的顺序 



## js数组的基本操作

- js中统计数组中元素出现的个数

  ```
  function getNumCount(arr) {
      return arr.reduce((pre,cur)=>{
          console.log(pre,cur)
          if(cur in pre){
              pre[cur]++
          }else{
              pre[cur] = 1
          }
          return  pre
      },{})
  }
  console.log(getNumCount([1,2,2,2,3,4,5,5])) 
  ```

  - js 数组去重

    ```
    function unique(arr) {
        return arr.reduce((pre,cur)=>{
            console.log(pre,cur)
            if(!pre.includes(cur)){
                pre.push(cur)
            }
            return  pre
        },[])
    }
    console.log(unique([1,2,2,2,3,4,5,5])) 
    ```

    注意 判断数组中是否有固定的某个数的方式

    返回 true 或者false的是 array.includes(searcElement[,fromIndex])  ！！！！

    - 1. 判断数组中是否存在某个值，如果存在返回true，否则返回false

      ```
      var arr=[1,2,3,4];
      if(arr.includes(3))
          console.log("存在");
      else
          console.log("不存在");
      ```

    - 2 array.indexOf   此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。

      ```
      var arr=[1,2,3,4];
      var index=arr.indexOf(3); 
      console.log(index); // 2  返回的是下标！！
      var index1=arr.indexOf(7); 
      console.log(index1); // -1
      ```

    - 3：array.find(callback[,thisArg])

      返回数组中满足条件的第一个元素的值，如果没有，返回undefined

      ```
      var arr=[1,2,3,4];
      var result = arr.find(item =>{
          return item > 9
      });
      console.log(result); //undefined
      
      ```

    - array.findeIndex(callback[,thisArg])

      返回数组中满足条件的第一个元素的下标，如果没有找到，返回`-1`

      ```
      var arr=[1,2,3,4];
      var result = arr.findIndex(item =>{
          return item > 3
      });
      console.log(result);
      ```

    - ```
      var arr=[1,2,3,4];
      var result = arr.findIndex(item =>{
          return item > 3
      });
      console.log(result);
      ```

      

      

      

      

      

      

    

- 遍历数组

  简单的 for  forEach

  ```
  var num = [1,3,4,5,7,9]
  for(let i=0; i<num.length;i++){
       console.log(num[i])
  }
  console.log("下面是用的forEach函数")
  num.forEach(element => {
      console.log(element)
  });
  ```

- 过滤数组

  *function(currentValue, index,arr)*    

  | *currentValue* | 必须。当前元素的值           |
  | -------------- | ---------------------------- |
  | *index*        | 可选。当前元素的索引值       |
  | *arr*          | 可选。当前元素属于的数组对象 |

  ````
  let arr = [56, 15, 48, 3, 7];
  let newArr = arr.filter((currentValue)=>{    // 参数的设置  currentValue 是当前的值 
      return currentValue%2===0
  })
  console.log(newArr)
  ````

- 条件筛选

  for 循环   filter 都行吧 

- 条件求和

  同上

- 最值筛选

  法子  可多了  不局限 

  ```
  var a=[1,3,9,8,5];
  var i,result=0;
  for(i=0;i<a.length;i++)
  {
  result=Math.max(result,a[i]);
  }
  console.log(result);
  ```

- map方法  类似于reduce

  注意：： 一定是赋值给新的数组  而不是在原数组上改变

  ```
  let nums = [1,2,3]
  nums1 = nums.map((i)=>{return i+1})
  console.log(nums1)
  ```

  







# 力扣刷题：

### **49 题 字母 异位分组**

// 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

 ```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
 ```

解题思路 ：

1. 非暴力 但非最优      

   先把每一个元素都排序      然后匹配相同就好了

2. 优秀解法 

```
var groupAnagrams = function(strs) {
    if(strs.length === 0){
        return []
    }
    let map = new  Map()
    for(const str of strs){
        var temple =Array(26).fill(0)
        for(let i=0;i<str.length;i++){
            let asci_i = str.charCodeAt(i) - 97
            temple[asci_i]++
          
        }

        const key = temple.join(".")
        console.log(key)

        if(map.has(key)){
            map.set(key,[...map.get(key),str])
        }else{
            map.set(key,[str])
        }
    }

    const result = []
    for(const arr of map){
        result.push(arr[1])
    }

    return result
}; 

let strs =["bdddddddddd","bbbbbbbbbbc"]

// let strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
// let strs = ["eat", "tea"]
console.log(groupAnagrams(strs))
```

### 54 螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素

![img](算法_基础理论.assets/spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

```
var spiralOrder = function(matrix) {
    if(matrix.length ==0){
        return []
    }

    let left = 0,top=0,bottom=matrix.length-1,right=matrix[0].length-1

    let result = []
    direction = "right"

    while(left<=right && top<=bottom){
        if(direction == 'right'){
            for(let i=left;i<=right;i++){
                result.push(matrix[top][i])
            }
            top++
            direction = 'bottom'
        }
        else if(direction == 'bottom'){
            for(let i=top;i<=bottom;i++){
                result.push(matrix[i][right])
            }
            right--
            direction = 'left'
        }
        else if(direction == 'left'){
            for(let i=right;i>=left;i--){
                result.push(matrix[bottom][i])
            }
            bottom--
            direction = 'top'
        }
        else if(direction == 'top'){
            for(let i=bottom;i>=top;i--){
                result.push(matrix[i][left])
            }
            left++
            direction = 'right'
        }
    }
    return result
};

let matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
console.log(spiralOrder(matrix))
```

### 55 跳跃游戏

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

##### ！！！ 动态规划

 ```
var canJump = function(nums) {
  if(nums.length==1)return false
  
  const dp = Array(nums.length-1).fill(false)
  console.log(dp)

  dp[0] = true

  for(let i=1 ;i<nums.length;++i){
      for(let j=i-1;j>=0;--j){
          if(!dp[j])continue
          if(nums[j]< i-j) continue
          dp[i]=true
          break
      }
  }
  return dp[nums.length-1]

};

// let nums = [2,3,1,1,4]
let nums = [3,2,1,0,4]
console.log(canJump(nums))
 ```

### 56合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

思路 ：先给所有的区间排序   然后 当一个区间的前一个值等与小于前一个区间   那就说明有重复的区域

```
var merge = function(intervals) {
    if(intervals.length<2) return intervals

    intervals.sort(function (a,b) {
        return a[0]-b[0]
    })

    let curr = intervals[0]
    let result = []
    
    for(let i=1; i<intervals.length; i++){
        if(curr[1]>=intervals[i][0]){
            curr[1] = Math.max(curr[1],intervals[i][1])
        }else{
            result.push(curr)
            curr = intervals[i]
        }
    }

    result.push(curr)
    return result
};

intervals = [[1,3],[2,6],[8,10],[15,18]]
console.log(merge(intervals))
```

### 62. 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

![img](算法_基础理论.assets/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

##### ！！！动态规划

```
var uniquePaths = function(m, n) {
    let memo = Array()

    for(let i=0;i<m;i++){
        memo.push([])
    }

    for(let row=0;row<m;row++){
        memo[row][0] = 1
    }
    for(let col=0;col<n;col++){
        memo[0][col] = 1
    }

    for(let row=1 ;row<m;row++){
        for(let col=1 ; col<n; col++){
            memo[row][col] = memo[row-1][col]+memo[row][col-1]
        }
    }
    return memo[m-1][n-1]
};

const m = 3, n = 7
console.log(uniquePaths(m,n))
```



### 66 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

```
var plusOne = function(digits) {
    for(let i=digits.length-1; i>=0; i--){
        if(digits[i]!=9){
            digits[i]++
            return digits
        }else{
            digits[i] = 0
        }
    }
    const result  = [1,...digits]
    //const result  = [1].concat(digits)
    return result
};
let digits = [9,9]
console.log(plusOne(digits))
```

### 70 爬楼梯

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

```
var climbStairs = function(n) {
    let memo = Array(n+1)
    memo[0] = 1
    memo[1] = 1
    for(let i=2; i<n+1; i++){
        memo[i] = memo[i-1] + memo[i-2]
    }
    return memo[n]
};

let n = 2
console.log(climbStairs(n))
```

### 930. 和相同的二元子数组

给你一个二元数组 `nums` ，和一个整数 `goal` ，请你统计并返回有多少个和为 `goal` 的 **非空** 子数组。

**子数组** 是数组的一段连续部分。

输入：nums = [1,0,1,0,1], goal = 2
输出：4
解释：
有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]

```
var numSubarraysWithSum = function(nums, goal) {
    let sum = 0
    let result = 0
    let preSum = []    
    for(let i = 0 ; i<nums.length+1 ;i++){
        preSum[i] = sum
        sum += nums[i]
        for(let j =0 ;j<i ;j++){
            if(preSum[i]-preSum[j] == goal){
                result +=1
            }
        }
    }
    return result
};

let nums = [0,0,0,0,0], goal = 0
console.log(numSubarraysWithSum(nums,goal))
```

### 17.10. 主要元素

数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。

```
输入：[1,2,5,9,5,9,5,5,5]
输出：5
```

```
var majorityElement = function(nums) {
    if(nums.length == 0) return 0
    if(nums.length == 1) return nums[0]
    let map = new Map()
    let maxNum = Math.ceil(nums.length/2) , key = 0
    for(let i = 0 ; i<nums.length ; i++){
        key = nums[i]
        if(map.has(key)){
            map.set(key, map.get(key) + 1)
            if(map.get(key)>=maxNum){
                return key
            }
        }else{
            map.set(key,1)
        }
    }
    return -1
};

let nums = [1,2,5,9,5,9,5,5,5]
console.log(majorityElement(nums))
```

### 704 二分查找

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

```
var search = function(nums, target) {
    
    let left = 0 ,right = nums.length -1
    let mid = 0
    while(left<=right){
        mid = Math.floor((right+left)/2)
        if(nums[mid] == target){
            return mid
        }else if(nums[mid] < target){
            left = mid+1
        }else if(nums[mid] > target){
            right = mid-1
        }
    }
    return -1
};

let nums = [5], target = 5
console.log(search(nums,target))
```

### 34. 在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

```
var searchRange = function(nums, target) {
    const findLeft =function (nums,target){
        let left = 0 ,right = nums.length -1
        let mid = 0
    
        while(left<=right){
            mid = Math.floor((right+left)/2)
            if(nums[mid] == target){
                right = mid-1
            }else if(nums[mid] < target){
                left = mid+1
            }else if(nums[mid] > target){
                right = mid-1
            }
        }
        return left
    }

    let result = new Array(2)
    if(findLeft(nums,target)>=nums.length || nums[findLeft(nums,target)]!=target) {
        return [-1,-1]
    }
    else{
        result=[findLeft(nums,target),findLeft(nums,target+1)-1]
    }

    return result
};

let nums = [5,7,7,8,8,10], target = 8
console.log(searchRange(nums,target))
```

73 矩阵置0

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

![img](算法_基础理论.assets/mat1.jpg)

```
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
```

思路：

```
var setZeroes = function(matrix) {
    let firstColHasZero = []
    let firstRowHasZero = []
    for(let i=0;i<matrix.length;i++){  //行数 
        if(matrix[i][0]==0){
            firstRowHasZero.push(i)
        }
    }
    console.log(firstRowHasZero)

    for(let i=0;i<matrix[0].length;i++){ //列数
        if(matrix[0][i]==0){
            firstColHasZero.push(i)
        }
    }

    console.log(firstColHasZero)

    for(let row = 1; row <matrix.length ;row++){
        for(let col = 1; col<matrix[0].length ;col++){
            if(matrix[row][col]==0){
                matrix[0][col] = 0
                matrix[row][0] = 0
            }
        }
    }


    for(let row = 1; row <matrix.length ;row++){
        for(let col = 1; col<matrix[0].length ;col++){
            if(matrix[row][0]==0 || matrix[0][col]==0){
                matrix[row][col] = 0
            }
        }
    }


    //如果有行有为0 的数  那么 把该 行 列 变成0 
    if(firstRowHasZero.length>0 ){
        for(let i=0;i<firstRowHasZero.length;i++){
            //取出 行  为0 的位置 
            for(let row = 0; row <matrix.length ;row++){    
                matrix[row][0] = 0
            }
            for(let col = 0; col<matrix[0].length ;col++){
                matrix[firstRowHasZero[i]][col] = 0
            }
        }
    }
   console.log(matrix)

   if(firstColHasZero.length>0){
    for(let i=0;i<firstColHasZero.length;i++){  
            for(let row = 0; row <matrix.length ;row++){
                matrix[row][firstColHasZero[i]] = 0
            }
            for(let col = 0; col<matrix[0].length ;col++){
                matrix[0][col] = 0
            }
        }
    }
    return matrix
}

let matrix = [[1,0]]

console.log(setZeroes(matrix))
```

### 121.买卖股票的最佳时机

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

minPrice的作用：必然是用当前的值减去前面最低的值用于更新，所以取一个变量存储前面的最小值。

Math.max(result,prices[i]-minPrice)如果出现 [3,7,1,2]这种情况，就需要比较两个上升的段哪一段利润最大。

```
var maxProfit = function(prices) {
    let minPrice = prices[0]
    let result = 0
    for(let i = 0; i<prices.length; i++){
        minPrice = Math.min(minPrice,prices[i])
        result = Math.max(result,prices[i]-minPrice)
    }
    return result
};

let prices = [1,2]
console.log(maxProfit(prices))
```

### 122. 买卖股票的最佳时机 II

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

及其简单的算法：

求！！求所有增长趋势的利润！！！

```
var maxProfit = function(prices) {
    let profit = 0
    for(let i = 0; i<prices.length; i++){
      if(prices[i]<prices[i+1]){
          profit += prices[i+1]-prices[i]
      }
    }
    return profit
};

let prices =  [7,1,5,3,6,4]
console.log(maxProfit(prices))
```











# 面经—算法



[TOC]

# **斐波那契数列介绍？**

> 别称：黄金分割数列

从第三位起，每个数字都是前两位数字之和

[3, 5, 8, 13, 21]



```
    //迭代法生成斐波那契数列
    function fib(n) {
        var fib_n = function(curr, next, n) {
            if (n == 0) {
                return curr;
            }
            else {
                return fib_n(next, curr+next, n-1);
            }
        }
        return fib_n(0, 1, n);
    }
    alert(fib(40));
```

```
var fib = function(n) {
    if(n==0) return 0
    if(n==1) return 1
    let dp = [0,1]
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    console.log(dp)
    return dp[n];
};

let n = 3
console.log(fib(n))
```

# **常见的算法有哪些？**

- **排序算法**：快速排序，归并排序 、计数排序（8大排序算法）
- **搜索算法**：回溯、递归、剪枝技巧
- **图论**：最短树、最小生成树、网络流建模
- **动态规划**：背包问题、最长子序列、计数问题
- **基础技巧**：分治、倍增、二分、贪心

参考资料：

[互联网公司最常见的面试算法题有哪些？](https://www.zhihu.com/question/24964987/answer/586425979)

https://www.zhihu.com/question/24964987/answer/586425979

# **分治算法？**

适用情况：

1. 规模缩小到一定程度就可以**容易地解决**
2. 可以分解为若干个较小的相同问题，具有**最优子结构性质**
3. 子问题的解**可以合并**为该问题的解
4. **子问题相互独立**，子问题不包含公共的子问题

**实现流程：**

> 类似数学归纳法，找到解决问题的求解方程公式，然后根据方程公式设计递归程序

1. 【分解】原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
2. 【解决】规模较小而容易则直接解决，否则递归解决子问题（考虑随着问题规模增大时的求解方法）
3. 【合并】将子问题的解合并的为原问题的解，找到求解的递归函数（各种规模和因子），设计递归程序即可

**使用案例：**

- 二分搜索
- 快速排序

参考资料：

[五大常用算法之一：分治算法](https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html)

# **递归算法介绍？**

> 函数中存着调用函数本身的情况，这种现象就叫递归

联想（汉诺塔）：

> 把用木块（一共5块）叠起来的金字塔，转换到另一个柱子上，可以使用一个中间柱子，每次只能移动一个木块，大木块不能压在小木块上面，最小路径

通用解决思路（步骤）：

- 【实现相同函数】把一个问题分解成具有相同解决思路的子问题，能调用一个函数实现
- 【终止条件】函数调用前判断终止条件

![img](https://images2015.cnblogs.com/blog/1026866/201610/1026866-20161016022859889-2055402664.jpg)

img

参考资料：

# **动态规划算法？**

参考资料：

[牛逼了，原来大神都是这样学动态规划的…](https://www.cxyxiaowu.com/8536.html)

# **贪心算法介绍？**

> 贪心算法（贪婪法），只考虑当下最优解，不考虑全局。希望从：局部最优解-> 全局最优解，并经常却不是

步骤：

1. 【拆分】：把问题拆成若干步骤
2. 【每步最优解】每一步都选取当前状态 最好/优的选择（局部最有利的选择）
3. 【循环】堆叠出的结果也是最好/优的解

联想（找零钱，最少数量）：找零钱：31块

> 核心思想：只考虑当下最优解，不考虑全局

- 找出符合条件中（x≤31），最优选择：20元
- 找出符合条件中（x≤11），最优选择：10元
- 找出符合条件中（x≤1），最优选择：1元

缺点案例：找零钱41元

如果此时货币面值里有（25元，20元，10元，5元，1元）

- 贪心算法的策略：25+10+5+1
- 实际最优解策略： 20+20+1

优点：

- 简单，高效，省去了为找最优解可能需要穷举操作，通常作为其他算法的辅助算法来使用

缺点：

- 不考虑总体，每次选取局部最优解，不再进行回溯处理，所以很少情况下得到最优解

参考资料：

[小白带你学---贪心算法（Greedy Algorithm)](https://zhuanlan.zhihu.com/p/53334049)

# **回溯算法介绍（属于深度优先搜索）？**

> 回溯法（试探法）：是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原来先把并不优或达不到目标，就退回一步重新先把，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态点称为“回溯点”

回溯法属性深度优先搜索，由于是全局搜索，复杂度相对高。

联想：

走迷宫，

- 【试探性执行】先选择一条路，开始走
- 【发现不通，准备返回】如果此路不通，再回到（回溯）上一个岔路口
- 【在节点换条路走】再下一条路，直到找到目的地；

参考资料：

[小白带你学---回溯算法（Back Tracking)](https://zhuanlan.zhihu.com/p/54275352)

# **数组排序？**

1. array的sort  方法 
2. 冒泡排序

# **常见的排序算法有哪些?**

1. 冒泡排序: ：相邻数对大小互换位置，循环对比两层完成
2. 选择排序：选择排序是最直观的排序，通过确认一个key最大或最小值，再和其他数中找到最大/小的值交换到对就位置
3. 插入排序：
4. 希尔排序
5. 归并排序
6. 快速排序：通过一趟排序将待排序记录分隔成独立的两部分，其中一部分记录的数据均比另一部分的数据小，则可分别对这两部分记录继续进行排序，以达到整个序列有序；
7. 堆排序
8. 计数排序：
9. 桶排序
10. 基数排序

参考资料（包含算法可视化动图）：https://github.com/damonare/Sorts

## **冒泡排序**

定义：相邻数对大小互换位置，循环对比两层完成

冒泡排序：

![img](https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.gif)

img

js sort()方法的原理： 冒泡排序法。

```
function BubbleSort(nums) {
let temp = 0
  for(let i = 0; i<nums.length; i++){
    for(let j = 0; j<nums.length; j++){
        if(nums[j]>nums[j+1]){
            temp = nums[j]
            nums[j] = nums[j+1]
            nums[j+1] = temp
         }
    }
  }  
  return nums
} 
let nums = [2,4,3,5,1]
console.log(BubbleSort(nums))
```

##### 力扣题目： 179. 最大数

给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。

```
输入：nums = [10,2]
输出："210"
```

   解题思路：先将数据排序，排序的时候比较的不是俩个数的大小   而是比组合的大小  就是比较 102 与210的大小！

```
var largestNumber = function(nums) {
   nums.sort((a,b)=>{
    let sa = 10,sb = 10
    while(sa<=a){
        sa*=10
    }
    while(sb<=b){
        sb*=10
    }
    console.log(a,b,sa,sb)
    return  (b*sa+a)-(a*sb+b)

   })
   
   return nums.join('')
};
 console.log(largestNumber([3,30]))
```

##### 力扣题目：324.摆动排序 II

给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

你可以假设所有输入数组都可以得到满足题目要求的结果。

示例 1：

输入：nums = [1,5,1,1,6,4]
输出：[1,6,1,5,1,4]
解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。

解题思路：

1.传统的方法将数组排序，将大的数字插入到晓得数字里面。 对于数组[1,1,2,2,3,3],分割为[1,1,2]和[2,3,3]。小的数组大于等于小数组的个数。为避免[1,1,2,2,**2**,3]，分割为[1,1,2]和[2,2,3]，最终结果为[1,**2**,1,**2**,**2**,3]的情况，我们将切割后的数组反序。再穿插但是这样的时间复杂度：O(NlogN)，空间复杂度为O(N)。

2.解法2：快速选择 + 3-way-partition

````
var wiggleSort = function(nums) {
    nums.sort((a,b)=>{
        return a-b
    })
    let len = nums.length-1
    let tmp = new Array(len)
    for(let i=1;i<nums.length;i+=2){
        tmp[i] = nums[len]
        len--
    }
    for(let j=0;j<nums.length;j+=2){
        tmp[j] = nums[len]
        len--
    }
    return tmp
};
let nums = [1,3,2,2,3,1]
console.log(wiggleSort(nums))
````



## **选择排序**

定义:选择排序是最直观的排序，通过确认一个key最大或最小值，再和其他数中找到最大/小的值交换到对就位置

算法实现：

- **确认比较值**：默认第一个
- **找到最小数**：找到剩余数中比比较值小的数 
- **位置替换**： 把找到的最小值替换到比较值的位置
- **重复步骤**： 二层循环

![img](https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.gif)

img

```
var changSort = function(nums) {
    let temp = 0
    for(let i=0; i<nums.length; i++){
        for(let j=i+1; j<nums.length; j++){
            if(nums[j]<nums[i]){
                temp = nums[j]
                nums [j] = nums[i]
                nums[i] = temp
            }
        }
    }
    return nums
};
let nums = [8,5,1,9,6,4]
console.log(changSort(nums))
```

## **快速排序**

定义：通过一趟排序将待排序记录分隔成独立的两部分，其中一部分记录的数据均比另一部分的数据小，则可分别对这两部分记录继续进行排序，以达到整个序列有序；

算法实现：

- **确认基准**：从数列中挑出一个元素，称为‘基准’(pivot)
- **分区操作**：小于基准放前，大于基于放后，完成后，基准就位于中间位置
- **递归操作（确认基准->分区操作)**：重复上面操作步骤 

![img](https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.gif)

img

```
function quickSort(arr) {
    if (arr.length <= 1) {
      return arr
    }
    let pivotIndex = Math.floor(arr.length / 2)
    let pivot = arr.splice(pivotIndex, 1)[0]

   console.log(pivotIndex,pivot)
   console.log(arr)

    let left = []
    let right = []
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] < pivot) {
        left.push(arr[i])
      } else {
        right.push(arr[i])
      }
    }
    // 递归
    return quickSort(left).concat([pivot], quickSort(right))
  }


let nums = [8,5,1,9,6,4]
result = quickSort(nums)
console.log(result)
```

## **插入排序**

定义：通过构建有序序列，对于未排序数据，在已排序序列中，从后向前扫描，找到相应位置并插入（联想：打扑克牌摸牌过程）

实现：

- **开始**：先取第一个元素，默认为有序数列
- **摸牌并比较**：在已经排序的数列上找到，从后向前查找，发现比他小的数据，就插入在它的后面

## **希尔排序**

> 是简单插入排序的改进版，它与插入排序的不同之处在于，它会优先比较距离较远的元素，别名缩小增量排序

定义：希尔排序的核心在于间隔序列（可提前设定好，也可动态定义间隔序列）的设定

# **常见的查找算法？**

## **二分查找法**

- 使用范围：找查对象是一个有序的数据结构
- 介绍：在一个有序数据中，将数据折中，每次折中的数据要和查找的数据进行比较，然后不断的缩小查找的范围，直到查到找或者区间为0为止；
- 案例：
  - 判断一个字母，数据在数组中的索引；
  - 猜数字游戏

## **线性查找**

- 使用范围：不限
- 特点：简单遍历，判断是否存在
- 案例：判断一个目标对象，在数据中的索引

# **二叉树介绍？**

> 二叉树是一种非常基础和重要的数据结构

运用：

- 前序：显示目录
- 中序：实现表达式，在编译器底层很用
- 后序：计算目录内的文件及其信息

特点：

- 每个结点的长度都不大于2
- 每个结点的孩子结点次序不能任意颠倒

二叉结的遍历方法分类：（要使用到栈、队列、递归等）

- 深度优先遍历
- 广度优先遍历

# **深度优先遍历和广度优先遍历的区别?**

二叉树的遍历概念。

**深度优先遍历（DFS）**：

定义：从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为 止。然后右子树节点遍历，直到遍历完所有可达节点为止。

分类：

- 前序：
- 中序：
- 后序：

**广度优先遍历（BFS）**：

定义：从根节点出发，在横向遍历二叉树的基础上，纵向遍历二叉树的层次；

遍历思想：递归

图示：

![img](https://img-blog.csdn.net/20170514174642802?watermark%2F2%2Ftext%2FaHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZ3dhbmdhbnl1%2Ffont%2F5a6L5L2T%2Ffontsize%2F400%2Ffill%2FI0JBQkFCMA=%3D%2Fdissolve%2F70%2Fgravity%2FCenter)

img

上图搜索顺序

DFS:ABDECFG

BFS:ABCDEFG

表达式用二叉树进行表示：

(a+b*c)-d/\*e*

![img](https://user-gold-cdn.xitu.io/2016/12/7/59115f76fbe825eea6de6a1749a8f5df.png?imageView2%2F0%2Fw%2F1280%2Fh%2F960%2Fformat%2Fwebp%2Fignore-error%2F1=)

img

参考资料： https://juejin.im/entry/6844903456277266446





# 面试算法题：

### 字节： 字节前端原题（Add sumOf）

给定有一个 Add 函数，要支持以下形式的调用

```text
Add(1)(2)(3).sumOf(); // 输出 6  
Add(1,2)(3)(4).sumOf(); // 输出 10  
Add(1,2,...)(3)(4)(...).sumOf();  // ...
```

  ```
  // JS函数柯里化  高阶函数
  function add(a,b) {
      return a+b
  }
  console.log(add(1,2))
  
  function curryingAdd(x) {
      return function (y) {
          return x+y
      }
  }
  console.log(curryingAdd(1)(2))
  ```

解题思路：

```
function Add1() {
    const nums = [...arguments];
    function AddPro() {
        nums.push(...arguments);
        return AddPro;
    }
    AddPro.sumOf = () => {
        return nums.reduce((a, b) => a + b);
    }
        return AddPro;
   }
console.log(Add1(1,2)(2)(3).sumOf())
```

### 2，求输出  字节

红宝书：

箭头函数可以没有｛｝，但是没有｛｝会改变函数的行为。 

有｛｝：代表包含 函数体 .  ｛｝内部是函数表达式   return不能省去

无｛｝：箭头函数后面只代表一行代码，会隐式返回这行代码的值！

这里注意**箭头函数**有两种格式：
1.只包含一个表达式，这时花括号和return都省略了。
2.包含多条语句，这时花括号和return都不能省略。

```
var fun1 = x => x
var fun2 = x => {x}
var fun3 = x => ({x})

console.log(fun1(1)) //1
console.log(fun2(1)) //undefined
console.log(fun3(1)) //{ x: 1 }
```



